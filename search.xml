<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LRU缓存的简易实现</title>
    <url>/2021/02/02/LRU%E7%BC%93%E5%AD%98%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>LRU(Least Recently Used)最近最少使用的缓存</p>
<p>对操作系统来说，一些经常访问的数据可以放入缓存来提高程序的执行效率，读定速度越高，成本越高，因此需要一个策略来决定缓存中放入哪些数据，LRU的思想是记录最近访问过的数据，当缓存满的时候，将访问频率最低的丢弃掉</p>
<p>本篇文章记录一下这个缓存的简易实现</p>
<p><img src="/2021/02/02/LRU%E7%BC%93%E5%AD%98%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/image-20210202235344125.png" alt="image-20210202235344125"></p>
</blockquote>
<h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><p>​        <strong>哈希表</strong>    一个存取复杂度几乎为O(1)的数据结构</p>
<p>​        <strong>双链表</strong>    维护访问顺序的双链表</p>
<h3 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h3><p>​        简单定义一下缓存的接口，放入数据，读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qgyyohj.lru;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        LRUCache实现，构造函数需要提供一个缓存的大小，初使化双链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Node&lt;K, V&gt;&gt; CACHE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt; HEAD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt; TAIL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 静态内部类，数据的存储载体，同时是双链表的一个结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    	Node&lt;K, V&gt; before;</span><br><span class="line">    	Node&lt;K, V&gt; after;</span><br><span class="line">    	K key;</span><br><span class="line">    	V val;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CAPACITY = capacity;</span><br><span class="line">        CACHE = <span class="keyword">new</span> HashMap&lt;&gt;(CAPACITY);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        HEAD = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        TAIL = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        HEAD.after = TAIL;</span><br><span class="line">        TAIL.before = HEAD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        当一个结点被加入缓存或者被访问后，将这个结点放到链表的末尾，这样，头指针指向的元素就是最不经常访问的元素</p>
<p>​        首先是<code>set</code>方法，用size字段来记录缓存中实际的元素数量，如果缓存中的元素数量达到阈值，就将头指针后的元素删除，同时修改链表的哈希表，将size减一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 删除头结点后的结点</span></span><br><span class="line">        Node&lt;K, V&gt; del = HEAD.after;</span><br><span class="line">        HEAD.after = del.after;</span><br><span class="line">        del.after.before = HEAD;</span><br><span class="line">        CACHE.remove(del.key);</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; node = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    node.key = key;</span><br><span class="line">    node.val = value;</span><br><span class="line">    CACHE.put(key, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把该结点添加到尾结点之前</span></span><br><span class="line">    TAIL.before.after = node;</span><br><span class="line">    node.before = TAIL.before;</span><br><span class="line">    node.after = TAIL;</span><br><span class="line">    TAIL.before = node;</span><br><span class="line"></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        当一个元素被访问的时候，就将他放到链表的末尾，从哈希表取到值返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CACHE.containsKey(key)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K, V&gt; node = CACHE.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改node前后指针</span></span><br><span class="line">    node.after.before = node.before;</span><br><span class="line">    node.before.after = node.after;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改当前结点</span></span><br><span class="line">    Node&lt;K, V&gt; end = TAIL.before;</span><br><span class="line"></span><br><span class="line">    end.after = node;</span><br><span class="line">    node.before = end;</span><br><span class="line">    node.after = TAIL;</span><br><span class="line">    TAIL.before = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CACHE.get(key).val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、测试-amp-小结"><a href="#三、测试-amp-小结" class="headerlink" title="三、测试&amp;小结"></a>三、测试&amp;小结</h3><p>​        声明一个大小为3的缓存，依次插入<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>四个元素，在插入<code>d</code>元素之前，访问一下<code>a</code>元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qgyyohj.lru;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cache&lt;String, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        cache.set(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        cache.set(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        cache.set(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        cache.set(<span class="string">&quot;d&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        从输出看来，被移除的是元素<code>b</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>​        总结：这就是一个简单的LinkedHashMap~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven配置阿里云仓库</title>
    <url>/2021/01/31/Maven%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p>默认配置下，maven速度慢得要死，替换镜像可以改善这个问题</p>
</blockquote>
<p>查看maven的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $M2_HOME</span><br></pre></td></tr></table></figure>
<p>查看maven的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat $M2_HOME/config/settings.xml</span><br></pre></td></tr></table></figure>
<p>查看生效的配置文件，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn help:effective-settings</span><br></pre></td></tr></table></figure>
<p>查看当前目录下合并了所有父pom的最终pom</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn help:effective-pom</span><br></pre></td></tr></table></figure>
<p>maven的配置文件会放在<code>$&#123;maven.home&#125;/conf/settings.xml</code>和<code> $&#123;user.home&#125;/.m2/settings.xml</code>两个目录下，前者是全局配置，后者是用户配置，用户配置会合并并覆盖全局配置</p>
<p>maven从主仓库拉镜像会非常慢，所以可以让maven去阿里的仓库中去拉依赖，在全局配置中用阿里云覆盖默认配置即可，mirrors中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>ServiceLoader</title>
    <url>/2021/02/01/ServiceLoader/</url>
    <content><![CDATA[<blockquote>
<p>日常开发中开发的多是API(Application Programming Interface)，定义接口，编定实现类，供调用方调用；</p>
<p>SPI(Service Provider Interface) 是另一种接口，由调用方定义，比如JDBC，接口在<code>java.sql</code>包中，通过<code>Class#forName</code>将实现类加载到内存中，供调用方使用</p>
<p>这篇文章来记录一个不一定有用但很好玩的接口<code>java.util.ServiceLoader</code></p>
</blockquote>
<p>定义一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qgyyohj.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qgyyohj.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoDeveloper</span> <span class="keyword">implements</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi, i am a Go developer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qgyyohj.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDeveloper</span> <span class="keyword">implements</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi, i am a Java developer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是主函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qgyyohj.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Developer&gt; serviceLoader = ServiceLoader.load(Developer.class);</span><br><span class="line">        serviceLoader.forEach(Developer::sayHi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个工作做完后，还需要在<code>resource</code>目录下创建一个<code>META-INF/services</code>文件夹，里面创建一个文件，文件名为接口的全限定名<code>com.qgyyohj.spi.Developer</code>内容是实现类的全限定名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.qgyyohj.spi.GoDeveloper</span><br><span class="line">com.qgyyohj.spi.JavaDeveloper</span><br></pre></td></tr></table></figure>
<p>整体结构如下</p>
<p><img src="/2021/02/01/ServiceLoader/image-20210201233805798.png" alt="image-20210201233805798"></p>
<p>点击运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hi, i am a Go developer.</span><br><span class="line">hi, i am a Java developer.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>程序中并没有显式调用两个实现类，两个类的方法却被执行了</p>
]]></content>
  </entry>
</search>
